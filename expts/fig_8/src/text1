  fn run_mlsys(&self, mix: &Mix) -> anyhow::Result<()> {
        let sim = SimKind::Mlsys;
        let cluster: Cluster = serde_json::from_str(&fs::read_to_string(&mix.cluster)?)?;
        let flows = self.flows(mix)?;

        let start_1 = Instant::now(); // timer start
        let start_read = Instant::now(); // timer start
        // construct SimNetwork
        let nodes = cluster.nodes().cloned().collect::<Vec<_>>();
        let links = cluster.links().cloned().collect::<Vec<_>>();
        let network = Network::new(&nodes, &links)?;
        let network = network.into_simulations_path(flows.clone());
        let (channel_to_flowid_map, path_to_flowid_map): (
            &FxHashMap<(NodeId, NodeId), FxHashSet<FlowId>>,
            &FxHashMap<Vec<(NodeId, NodeId)>, FxHashSet<FlowId>>
        ) = match network.get_routes() {
            Some((channel_map, path_map)) => (channel_map, path_map),
            None => panic!("Routes not available"),
        };
        
        // // Collect lengths into a vector
        // let mut lengths: Vec<usize> = path_to_flowid_map.iter()
        // .map(|(_, value)| value.len())
        // .collect();

        // // Sort the vector to enable percentile calculation
        // lengths.sort_unstable();

        // // Calculate the 90th percentile index
        // // Note: subtract 1 because vector indices start at 0
        // let flows_on_path_threshold_idx = ((lengths.len() as f32) * 0.1).ceil() as usize - 1;
        // let flows_on_path_threshold= lengths[flows_on_path_threshold_idx];
        // println!("flows_on_path_threshold: {}", flows_on_path_threshold);
        
        let path_to_flows_vec_sorted = path_to_flowid_map
            .iter()
            .filter(|(_, value)| value.len() >= FLOWS_ON_PATH_THRESHOLD)
            .collect::<Vec<_>>();
        let elapsed_read= start_read.elapsed().as_secs();

        let start_sample= Instant::now(); // timer start
        let mut path_list: Vec<Vec<(NodeId, NodeId)>>;
        let mut path_counts: FxHashMap<Vec<(NodeId, NodeId)>, usize> = FxHashMap::default();

        // path sampling: randomly select N flows, with the probability of a flow being selected proportional to the number of paths it is on
        let weights: Vec<usize> = path_to_flows_vec_sorted.iter()
        .map(|(_, flows)| flows.len()).collect();
        let weighted_index = WeightedIndex::new(weights).unwrap();

        let mut rng = StdRng::seed_from_u64(self.seed);
        (0..NR_PATHS_SAMPLED).for_each(|_| {
            let sampled_index = weighted_index.sample(&mut rng);
            let key = path_to_flows_vec_sorted[sampled_index].0.clone();
            // Update counts
            *path_counts.entry(key).or_insert(0) += 1;
        });

        // Derive the unique set of paths
        path_list = path_counts.clone().into_keys().collect();

        path_list.sort_by(|x, y| y.len().cmp(&x.len()).then(path_to_flowid_map[y].len().cmp(&path_to_flowid_map[x].len())));
        let elapsed_sample= start_sample.elapsed().as_secs();

        let start_path = Instant::now(); // timer start
        let results:Vec<_> = path_list
            .par_iter()
            .enumerate()
            .map(|(path_idx, path)| {
                let mut start_tmp = Instant::now();
                let mut flow_ids_in_f_prime: HashSet<FlowId> = HashSet::new();

                let mut flow_to_srcdst_map_in_flowsim: FxHashMap<FlowId, Vec<(usize, usize)>> = FxHashMap::default();
                let mut path_length = 1;
                for src_dst_pair in path.iter().skip(1) {
                    if let Some(flows_on_path) = channel_to_flowid_map.get(src_dst_pair) {
                        flow_ids_in_f_prime.extend(flows_on_path);
                        for &key_flowid in flows_on_path {
                            // println!("flow {} is on path {}", key_flowid, idx);
                            if let Some(count_vec) = flow_to_srcdst_map_in_flowsim.get_mut(&key_flowid) {
                                if count_vec.last().unwrap().1 != path_length - 1 {
                                    count_vec.push((path_length - 1, path_length));
                                }
                                else {
                                    count_vec.last_mut().unwrap().1 = path_length;
                                }
                            } else {
                                let tmp=vec![(path_length - 1, path_length)];
                                flow_to_srcdst_map_in_flowsim
                                    .insert(key_flowid, tmp);
                            }
                        }
                        path_length += 1;
                    }
                }
                // assert_eq!(path_length, path.len());

                // get flows for a specific path
                let mut flows_remaining: Vec<Flow> = flow_ids_in_f_prime
                .iter()
                .filter_map(|&flow_id| flows.get(flow_id.as_usize()).cloned())
                .collect();
                
                let mut flow_extra: Vec<Flow>=Vec::new();

                for flow in flows_remaining.iter_mut() {
                    if let Some(count_vec) = flow_to_srcdst_map_in_flowsim.get(&flow.id) {
                        flow.src = NodeId::new(count_vec[0].0);
                        flow.dst = NodeId::new(count_vec[0].1);
                        for i in 1..count_vec.len() {
                            let mut tmp=flow.clone();
                            tmp.src = NodeId::new(count_vec[i].0);
                            tmp.dst = NodeId::new(count_vec[i].1);
                            tmp.id=FlowId::new(flow_extra.len()+NR_FLOWS);
                            flow_extra.push(tmp);
                        }
                    }
                }
                flows_remaining.extend(flow_extra);

                flows_remaining.sort_by(|a, b| a.start.cmp(&b.start));

                let elapsed_secs_preprop = start_tmp.elapsed().as_secs();
                start_tmp= Instant::now();
                let mlsys = Mlsys::builder()
                    .script_path(MLSYS_PATH)
                    .data_dir(self.sim_dir_with_idx(mix, sim, path_idx).unwrap())
                    .flows(flows_remaining)
                    .seed(self.seed)
                    // .input_percentiles(INPUT_PERCENTILES.to_vec())
                    .input_percentiles((1..=100).map(|x| x as f32 / 100.0).collect())
                    .nr_size_buckets(NR_SIZE_BUCKETS)
                    .output_length(OUTPUT_LEN)
                    .bfsz(mix.bfsz)
                    .window(Bytes::new(mix.window))
                    .enable_pfc(mix.enable_pfc)
                    .cc_kind(mix.cc)
                    .param_1(mix.param_1)
                    .param_2(mix.param_2)
                    .model_suffix(MODEL_SUFFIX.to_string())
                    .build();
                let result = mlsys.run(path_length);

                let elapsed_secs_mlsys = start_tmp.elapsed().as_secs();
                
                let path_str = path
                    .iter()
                    .map(|&x| format!("{}-{}", x.0, x.1))
                    .collect::<Vec<String>>()
                    .join("|");
                let flow_ids_in_f_str = path_to_flowid_map[path].iter().map(|&x| x.to_string()).collect::<Vec<String>>().join(",");
                self.put_path_with_idx(
                    mix,
                    sim,
                    path_idx,
                    format!(
                        "{},{},{},{}\n{},{}\n{}",
                        path_str,
                        path_to_flowid_map[path].len(),
                        flow_ids_in_f_prime.len(),
                        path_counts[path],
                        elapsed_secs_preprop,
                        elapsed_secs_mlsys,
                        flow_ids_in_f_str
                    ),
                )
                .unwrap();
                result
            }).collect();
        println!("{}: {}", mix.id,results.len());

        let mut results_str = String::new();
        for result in results {
            let tmp=result.unwrap();
            for vec in tmp.iter() {
                results_str.push_str(&format!("{}\n", vec.iter().map(|&x| x.to_string()).collect::<Vec<_>>().join(",")));
            }
        }
        
        self.put_path(mix, sim, format!("{},{}\n{}", NR_PATHS_SAMPLED,path_list.len(),results_str))
                .unwrap();
        
        let elapsed_path = start_path.elapsed().as_secs(); // timer end
        let elapsed_1 = start_1.elapsed().as_secs(); // timer end

        self.put_elapsed_str(mix, sim, format!("{},{},{},{}", elapsed_1, elapsed_read,elapsed_sample,elapsed_path))?;
        Ok(())
    }

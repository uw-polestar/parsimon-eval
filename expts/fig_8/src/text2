fn run_ns3_path_all(&self, mix: &Mix) -> anyhow::Result<()> {
    let sim = SimKind::Ns3PathAll;
    let cluster: Cluster = serde_json::from_str(&fs::read_to_string(&mix.cluster)?)?;
    let flows = self.flows(mix)?;

    let start_1 = Instant::now(); // timer start
    let start_read = Instant::now(); // timer start
    // construct SimNetwork
    let nodes = cluster.nodes().cloned().collect::<Vec<_>>();
    let links = cluster.links().cloned().collect::<Vec<_>>();
    let network = Network::new(&nodes, &links)?;
    let network = network.into_simulations_path(flows.clone());
    let (channel_to_flowid_map, path_to_flowid_map): (
        &FxHashMap<(NodeId, NodeId), FxHashSet<FlowId>>,
        &FxHashMap<Vec<(NodeId, NodeId)>, FxHashSet<FlowId>>
    ) = match network.get_routes() {
        Some((channel_map, path_map)) => (channel_map, path_map),
        None => panic!("Routes not available"),
    };

    let path_to_flows_vec_sorted = path_to_flowid_map
        .iter()
        .filter(|(_, value)| value.len() >= FLOWS_ON_PATH_THRESHOLD)
        .collect::<Vec<_>>();
    let elapsed_read= start_read.elapsed().as_secs();

    let start_sample= Instant::now(); // timer start
    let mut path_list: Vec<Vec<(NodeId, NodeId)>>;
    let mut path_counts: FxHashMap<Vec<(NodeId, NodeId)>, usize> = FxHashMap::default();

    let weights: Vec<usize> = path_to_flows_vec_sorted.iter()
    .map(|(_, flows)| flows.len()).collect();
    let weighted_index = WeightedIndex::new(weights).unwrap();

    let mut rng = StdRng::seed_from_u64(self.seed);
    (0..NR_PATHS_SAMPLED_NS3).for_each(|_| {
        let sampled_index = weighted_index.sample(&mut rng);
        let key = path_to_flows_vec_sorted[sampled_index].0.clone();
        // Update counts
        *path_counts.entry(key).or_insert(0) += 1;
    });

    // Derive the unique set of paths
    path_list = path_counts.clone().into_keys().collect();
    
    path_list.sort_by(|x, y| y.len().cmp(&x.len()).then(path_to_flowid_map[y].len().cmp(&path_to_flowid_map[x].len())));
    let elapsed_sample= start_sample.elapsed().as_secs();

    let start_path = Instant::now(); // timer start
    path_list
        .par_iter()
        .enumerate()
        .for_each(|(path_idx, path)| {
            let mut start_tmp = Instant::now();
            let flow_ids_in_f = path_to_flowid_map[path]
                .iter()
                .collect::<HashSet<_>>();
            let mut flow_ids_in_f_prime: HashSet<FlowId> = HashSet::new();
            for src_dst_pair in path.iter().skip(1) {
                if let Some(flows_on_path) = channel_to_flowid_map.get(src_dst_pair) {
                    flow_ids_in_f_prime.extend(flows_on_path);
                }
            }

            // get flows for a specific path
            let mut flows_remaining: Vec<Flow> = flow_ids_in_f_prime
            .iter()
            .filter_map(|&flow_id| flows.get(flow_id.as_usize()).cloned())
            .collect();
            flows_remaining.sort_by(|a, b| a.start.cmp(&b.start));

            let elapsed_secs_preprop = start_tmp.elapsed().as_secs();
            start_tmp= Instant::now();
            let data_dir=self.sim_dir_with_idx(mix, sim, path_idx).unwrap();
            let ns3 = Ns3Simulation::builder()
                .ns3_dir(NS3_DIR)
                .data_dir(data_dir.clone())
                .nodes(cluster.nodes().cloned().collect::<Vec<_>>())
                .links(cluster.links().cloned().collect::<Vec<_>>())
                // .window(WINDOW)
                .base_rtt(BASE_RTT)
                .flows(flows_remaining)
                .bfsz(mix.bfsz)
                .window(Bytes::new(mix.window))
                .enable_pfc(mix.enable_pfc)
                .cc_kind(mix.cc)
                .param_1(mix.param_1)
                .param_2(mix.param_2)
                .build();
            let records = ns3
                .run()
                .unwrap()
                .into_iter()
                .filter(|rec| flow_ids_in_f.contains(&rec.id))
                .map(|rec| Record {
                    mix_id: mix.id,
                    flow_id: rec.id,
                    size: rec.size,
                    slowdown: rec.slowdown(),
                    sim,
                })
                .collect::<Vec<_>>();
            
            let elapsed_secs_mlsys = start_tmp.elapsed().as_secs();

            let path_str = path
                .iter()
                .map(|&x| format!("{}-{}", x.0, x.1))
                .collect::<Vec<String>>()
                .join("|");
            let flow_ids_in_f_str = flow_ids_in_f.iter().map(|&x| x.to_string()).collect::<Vec<String>>().join(",");
            self.put_path_with_idx(
                mix,
                sim,
                path_idx,
                format!(
                    "{},{},{},{}\n{},{}\n{}",
                    path_str,
                    flow_ids_in_f.len(),
                    flow_ids_in_f_prime.len(),
                    path_counts[path],
                    elapsed_secs_preprop,
                    elapsed_secs_mlsys,
                    flow_ids_in_f_str,
                    // flow_ids_in_f_prime_str
                ),
            )
            .unwrap();
            self.put_records_with_idx(mix, sim, path_idx, &records)
                .unwrap();
            ns3_clean(data_dir).unwrap();
        });
    let elapsed_path = start_path.elapsed().as_secs(); // timer end
    let elapsed_1 = start_1.elapsed().as_secs(); // timer end
    self.put_elapsed_str(mix, sim, format!("{},{},{},{}", elapsed_1, elapsed_read,elapsed_sample,elapsed_path))?;
    println!("{}: {}", mix.id,elapsed_1);
    Ok(())
}